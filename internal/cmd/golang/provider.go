// Package golang implements the language provider for Go
package golang

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	
	"github.com/caezarr-oss/scotter/internal/embedded"
	"github.com/caezarr-oss/scotter/pkg/plugin"
	"gopkg.in/yaml.v3"
)

const (
	// GoVersion is the Go version to use in project templates
	// Set to 1.21 to avoid potential compatibility issues as per identified issues
	GoVersion = "1.21"
)

// GoLanguageProvider implements the LanguageProvider interface for Go
type GoLanguageProvider struct {
	templateManager plugin.TemplateManager
}

// NewGoLanguageProvider creates a new Go language provider
func NewGoLanguageProvider() *GoLanguageProvider {
	return &GoLanguageProvider{
		templateManager: embedded.NewTemplateManager(),
	}
}

// Name returns the plugin name
func (p *GoLanguageProvider) Name() string {
	return "go"
}

// SupportedProjectTypes returns project types supported by this language
func (p *GoLanguageProvider) SupportedProjectTypes() []string {
	return []string{"cli", "api", "library", "default"}
}

// Initialize initializes a new project
func (p *GoLanguageProvider) Initialize(projectName, projectType string, config map[string]interface{}) error {
	projectDir := projectName
	
	// Validate project type
	if !contains(p.SupportedProjectTypes(), projectType) {
		return fmt.Errorf("unsupported project type '%s' for Go language", projectType)
	}
	
	// Create module
	moduleCmd := exec.Command("go", "mod", "init", fmt.Sprintf("github.com/%s", projectName))
	moduleCmd.Dir = projectDir
	if err := moduleCmd.Run(); err != nil {
		return fmt.Errorf("failed to initialize Go module: %w", err)
	}

	// Create directory structure based on project type
	switch projectType {
	case "cli":
		if err := os.MkdirAll(filepath.Join(projectDir, "cmd"), 0755); err != nil {
			return err
		}
		if err := os.MkdirAll(filepath.Join(projectDir, "internal"), 0755); err != nil {
			return err
		}
	case "api":
		if err := os.MkdirAll(filepath.Join(projectDir, "api"), 0755); err != nil {
			return err
		}
		if err := os.MkdirAll(filepath.Join(projectDir, "internal"), 0755); err != nil {
			return err
		}
		if err := os.MkdirAll(filepath.Join(projectDir, "pkg"), 0755); err != nil {
			return err
		}
	case "library":
		if err := os.MkdirAll(filepath.Join(projectDir, "pkg"), 0755); err != nil {
			return err
		}
	}

	// Template paths will be used when template system is fully implemented
	// For now we're using direct file generation

	// Prepare template data
	data := map[string]interface{}{
		"ProjectName": projectName,
		"GoVersion":   GoVersion,
	}

	// Add any additional config
	for k, v := range config {
		data[k] = v
	}

	// Create main.go or lib.go
	var targetPath string
	if projectType == "library" {
		targetPath = filepath.Join(projectDir, fmt.Sprintf("%s.go", projectName))
	} else if projectType == "cli" {
		targetPath = filepath.Join(projectDir, "cmd", "main.go")
	} else {
		targetPath = filepath.Join(projectDir, "main.go")
	}

	// Write file with basic content as placeholder since templates aren't yet implemented
	basicContent := "package main\n\nfunc main() {\n\t// Generated by Scotter\n}\n"
	if projectType == "library" {
		basicContent = fmt.Sprintf("package %s\n\n// HelloWorld is an example function\nfunc HelloWorld() string {\n\treturn \"Hello from %s!\"\n}\n", projectName, projectName)
	}

	if err := os.WriteFile(targetPath, []byte(basicContent), 0644); err != nil {
		return fmt.Errorf("failed to create source file: %w", err)
	}

	// Create README.md
	readmePath := filepath.Join(projectDir, "README.md")
	readmeContent := fmt.Sprintf("# %s\n\n%s project scaffolded with Scotter.\n", 
		strings.Title(projectName), 
		strings.Title(projectType))
	if err := os.WriteFile(readmePath, []byte(readmeContent), 0644); err != nil {
		return fmt.Errorf("failed to create README.md: %w", err)
	}

	// Add .gitignore
	gitignorePath := filepath.Join(projectDir, ".gitignore")
	gitignoreContent := `# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with "go test -c"
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work

# Binary output
/bin/
/dist/
`
	if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
		return fmt.Errorf("failed to create .gitignore: %w", err)
	}

	return nil
}

// GenerateReleaseScript generates a release script with appropriate configuration based on the project type
func (p *GoLanguageProvider) GenerateReleaseScript(projectPath string, config map[string]interface{}) error {
	// Check if GoReleaser is already configured
	goreleaserPath := filepath.Join(projectPath, ".goreleaser.yaml")
	if _, err := os.Stat(goreleaserPath); err == nil {
		return fmt.Errorf(".goreleaser.yaml already exists")
	}

	// Get project type from config
	var projectType string
	if config != nil {
		if typeVal, ok := config["project_type"].(string); ok {
			projectType = typeVal
		}
	}
	
	// If we couldn't determine the project type, check for common patterns
	if projectType == "" {
		// Check if there is a main.go file (indicates executable project)
		mainPath := filepath.Join(projectPath, "main.go")
		if _, err := os.Stat(mainPath); err == nil {
			// Default to CLI if there's a main.go
			projectType = "cli"
		} else {
			// Default to library otherwise
			projectType = "library"
		}
	}
	
	var goreleaserConfig string
	
	if projectType == "library" {
		// For library projects, we don't build binaries
		goreleaserConfig = `# GoReleaser configuration for Go library
# Make sure to check the documentation at http://goreleaser.com
version: 2

before:
  hooks:
    - go mod tidy
    - go test -v ./...

# Explicitly disable builds for libraries
builds:
  - skip: true

# Source distribution for libraries
source:
  enabled: true

checksum:
  name_template: 'checksums.txt'
  
changelog:
  sort: asc
  use: git
  filters:
    exclude:
      - '^docs:'
      - '^test:'
      - '^ci:'
      - Merge pull request
      - Merge branch
      
sboms:
  - artifacts: source
`
	} else {
		// Find the main.go file for CLI/API projects
		mainPath := "./main.go" // Default location
		
		// Check if main.go exists in the root directory
		if _, err := os.Stat(filepath.Join(projectPath, "main.go")); err != nil {
			// Main.go not in root, try to find it in common locations
			possibleLocations := []string{
				"cmd/main.go",
				"cmd/app/main.go",
				"cmd/server/main.go",
				"cmd/cli/main.go",
				"cmd/api/main.go",
			}
			
			found := false
			for _, loc := range possibleLocations {
				if _, err := os.Stat(filepath.Join(projectPath, loc)); err == nil {
					mainPath = "." + string(os.PathSeparator) + loc
					found = true
					break
				}
			}
			
			// If still not found, try more exhaustive search
			if !found {
				err := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {
					if err != nil {
						return err
					}
					if !info.IsDir() && info.Name() == "main.go" {
						relPath, err := filepath.Rel(projectPath, path)
						if err == nil {
							mainPath = "." + string(os.PathSeparator) + relPath
							found = true
							return filepath.SkipAll
						}
					}
					return nil
				})
				if err != nil {
					fmt.Printf("Warning: Error searching for main.go: %v\n", err)
				}
			}
		}

		// For CLI/API/default projects, build binaries
		goreleaserConfig = fmt.Sprintf(`# GoReleaser configuration for Go executable projects
# Make sure to check the documentation at http://goreleaser.com
version: 2

before:
  hooks:
    - go mod tidy
    - go test -v ./...

builds:
  - env:
      - CGO_ENABLED=0
    main: %s
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    ldflags:
      - -s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.date={{.Date}} -X main.builtBy=goreleaser

archives:
  - format_overrides:
    - goos: windows
      format: zip
    name_template: >-
      {{ .ProjectName }}_
      {{- title .Os }}_
      {{- if eq .Arch "amd64" }}x86_64
      {{- else if eq .Arch "386" }}i386
      {{- else }}{{ .Arch }}{{ end }}
      {{- if .Arm }}v{{ .Arm }}{{ end }}

checksum:
  name_template: 'checksums.txt'

changelog:
  sort: asc
  use: git
  filters:
    exclude:
      - '^docs:'
      - '^test:'
      - '^ci:'
      - Merge pull request
      - Merge branch

sboms:
  - artifacts: archive
`, mainPath)
	}

	// Write the GoReleaser configuration
	if err := os.WriteFile(goreleaserPath, []byte(goreleaserConfig), 0644); err != nil {
		return fmt.Errorf("failed to create GoReleaser configuration: %w", err)
	}

	return nil
}

// AddPlatform adds support for a new platform
func (p *GoLanguageProvider) AddPlatform(projectPath, platform string) error {
	// Validate platform
	validPlatforms := []string{"linux", "darwin", "windows", "freebsd", "netbsd", "openbsd", "plan9", "solaris"}
	if !contains(validPlatforms, platform) {
		return fmt.Errorf("unsupported platform '%s' for Go language", platform)
	}

	// Check for .goreleaser.yaml
	goreleaserPath := filepath.Join(projectPath, ".goreleaser.yaml")
	if _, err := os.Stat(goreleaserPath); os.IsNotExist(err) {
		// Load project configuration from .scotter.yaml
		configPath := filepath.Join(projectPath, ".scotter.yaml")
		configData, err := os.ReadFile(configPath)
		
		// If we can read the config file, use it to generate the release script
		if err == nil {
			config := make(map[string]interface{})
			if err := yaml.Unmarshal(configData, &config); err == nil {
				// Generate GoReleaser configuration with the project config
				if err := p.GenerateReleaseScript(projectPath, config); err != nil {
					return err
				}
			} else {
				// Fall back to nil config if we can't parse the yaml
				if err := p.GenerateReleaseScript(projectPath, nil); err != nil {
					return err
				}
			}
		} else {
			// Fall back to nil config if we can't read the file
			if err := p.GenerateReleaseScript(projectPath, nil); err != nil {
				return err
			}
		}
	}

	// For now, we'll just notify that the platform will be added in the GoReleaser configuration
	// In a real implementation, this would modify the .goreleaser.yaml file
	fmt.Printf("Platform '%s' will be added to GoReleaser configuration\n", platform)

	return nil
}

// AddReleaseAsset adds support for a new release asset type
func (p *GoLanguageProvider) AddReleaseAsset(projectPath, assetType string) error {
	// Validate asset type
	validAssetTypes := []string{"checksum", "sbom", "archive"}
	if !contains(validAssetTypes, assetType) {
		return fmt.Errorf("unsupported release asset type '%s' for Go language", assetType)
	}

	// Check for .goreleaser.yaml
	goreleaserPath := filepath.Join(projectPath, ".goreleaser.yaml")
	if _, err := os.Stat(goreleaserPath); os.IsNotExist(err) {
		// Load project configuration from .scotter.yaml
		configPath := filepath.Join(projectPath, ".scotter.yaml")
		configData, err := os.ReadFile(configPath)
		
		// If we can read the config file, use it to generate the release script
		if err == nil {
			config := make(map[string]interface{})
			if err := yaml.Unmarshal(configData, &config); err == nil {
				// Generate GoReleaser configuration with the project config
				if err := p.GenerateReleaseScript(projectPath, config); err != nil {
					return err
				}
			} else {
				// Fall back to nil config if we can't parse the yaml
				if err := p.GenerateReleaseScript(projectPath, nil); err != nil {
					return err
				}
			}
		} else {
			// Fall back to nil config if we can't read the file
			if err := p.GenerateReleaseScript(projectPath, nil); err != nil {
				return err
			}
		}
	}

	// For now, we'll just notify that the asset type will be added in the GoReleaser configuration
	// In a real implementation, this would modify the .goreleaser.yaml file
	fmt.Printf("Release asset type '%s' will be added to GoReleaser configuration\n", assetType)

	return nil
}

// Helper function to check if a slice contains a string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
